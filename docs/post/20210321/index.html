<!doctype html><html lang=en><head><title>MySQL 8.0 のロックスケジューラ CATS</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet href=../../css/theme.css></head><body><div id=content class=mx-auto><header class="container mt-sm-5 mt-4 mb-4 mt-xs-1"><div class=row><div class="col-sm-4 col-12 text-sm-right text-center pt-sm-4"><a href=../../ class=text-decoration-none><img id=home-image class=rounded-circle src=../../images/avatar.png></a></div><div class="col-sm-8 col-12 text-sm-left text-center"><h2 class="m-0 mb-2 mt-4"><a href=../../ class=text-decoration-none>Ryosei Iwai</a></h2><p class="text-muted mb-1">Software, Infra Engineer / iwakero / GREE, inc.</p><ul id=nav-links class="list-inline mb-2"><li class=list-inline-item><a class="badge badge-white" href=../../about/ title=About>About</a></li><li class=list-inline-item><a class="badge badge-white" href=../../post/ title=Posts>Posts</a></li><li class=list-inline-item><a class="badge badge-white" href=../../categories/ title=Categories>Categories</a></li><li class=list-inline-item><a class="badge badge-white" href=../../tags/ title=tags>Tags</a></li></ul><ul id=nav-social class=list-inline><li class="list-inline-item mr-3"><a href=https://github.com/zensai3805 target=_blank><i class="fab fa-github fa-1x text-muted"></i></a></li><li class="list-inline-item mr-3"><a href=https://twitter.com/zensai3805 target=_blank><i class="fab fa-twitter fa-1x text-muted"></i></a></li></ul></div></div><hr></header><div class=container><div class=pl-sm-2><div class=mb-3><h3 class=mb-0>MySQL 8.0 のロックスケジューラ CATS</h3><small class=text-muted>Published March 21, 2021</small></div><article><p>MySQL 8.0.3 にて Innodb の default にされたロックスケジューラ CATS について調べたので、自分なりにまとめてみる</p><h4 id=cats-の略>CATS の略</h4><p>Contention-Aware Transaction Scheduling の略</p><p>日本語訳すると、コンテンションを意識したトランザクションスケジューリング。</p><h4 id=ロックスケジューラについて>ロックスケジューラについて</h4><p>ロックスケジューラーは、複数のトランザクションが同一のオブジェクトのロックを取ろうとした時、どれが最初にロックを取るべきかを決定する。</p><p>どのトランザクションを優先すべきかはグラフの依存関係の解決が必要であり、NP困難となる例が多い。そのため 8.0 より前の MySQL や多くの database system では、 FIFO(First-In-First-Out)系のアルゴリズムを採用している。要は最初に要求がきたトランザクションにそのロックを与える方式で、これはシンプルである。</p><p>CATAS は上記従来のアルゴリズムよりレイテンシーを減少させ、スループットを向上させるアルゴリズムとして提案された。</p><h4 id=cats-の仕組み>CATS の仕組み</h4><p>CATS はひとつの単純な直感に基づいている。</p><p>「全てのトランザクションは等価ではなく、全てのオブジェクトも等価ではない」</p><p>あるトランザクションが既に多くのトランザクションが待っているオブジェクトのロックを取っているなら、そのトランザクションが新たに要求するロックは、優先的に与えられるべきである。何故なら、このようなトランザクションのロックを優先して開放していく事は、全体としてより多くのロックを開放する事に繋がるからである。</p><p>例えるなら同じコーヒーの行列に並ぶタクシー運転手とバスの運転手。バスの運転手に優先してコーヒーを提供する事は、結果的により多くの人をより早く目的地に到着させる。</p><p>ただし、CATS は常に適用されている訳ではなく、待機しているトランザクションが 32 を超える場合に適用される。この数字はテストによって決定された。</p><p>( 確かにパフォーマンス比較をみると、 client 数が 64 を超えない限りは FIFO と CATS に差がない、比較はブログ参照 )</p><p>以下、読んでいて感じた疑問と、その解決</p><h5 id=疑問1-タクシーの運転手永遠にコーヒー飲めない問題>疑問1. タクシーの運転手、永遠にコーヒー飲めない問題</h5><p>個人的疑問としては、この手のスケジューリングの問題として、結果優先度が低いやつが永遠に待たされる問題がよく挙げられる。</p><p>と思って調べたら、既に<a href=https://mysqlserverteam.com/contention-aware-transaction-scheduling-arriving-in-innodb-to-boost-performance/#comment-18329>ブログ</a>で質問がされていた。</p><p>===</p><p>スタベーションの問題はどう扱っていますか？</p><p>例に挙げられているバスとタクシーではバスを優先する事は理にかなっていますが、常にバスのキューが2つ並んでいると、タクシーには順番は回ってきません。このようなケースは自然に解決されますか？</p><p>Peter Zaitsev</p><p>===</p><p>この質問への回答は、</p><p><strong>1. バスとタクシーの例はあるが、実際には全てのトランザクションはタクシーである</strong></p><p>確かにこれは例えの罠で、トランザクションがロックを取った時点では、そのトランザクションを待っている大量のトランザクションというのは存在しない。時間経過と共に増えていくので、常に大量のトランザクションを待たせた奴が来続けるという状況は多くはないのか。</p><p><strong>2. 色々対策のアルゴリズムも入っている</strong></p><p>挙げられているものは、</p><ol><li>ロックの待機時間が長いトランザクションの優先度を上げる</li><li>ロックキューに時々バリアを入れて、バリアの前のキューを捌くようにする</li></ol><p>などなど、今後新たに導入される奴もあるらしい。</p><h5 id=疑問2-トランザクションの優先度の観点の問題>疑問2. トランザクションの優先度の観点の問題</h5><p>トランザクションの全体での優先度の観点について、待っているトランザクションの数を重要度として採用する事の根拠を知りたかった。</p><p>この辺は、<a href=https://dl.acm.org/doi/10.1145/3187009.3177740>論文</a>を読んだ所ある程度書いてあった。</p><p>トランザクションの依存関係グラフからリアルタイムに正確な優先度を求める事は難しいので、ヒューリスティックに優先度を求める必要がある。そこで論文では以下のように色々な観点を比較している。</p><p><strong>案1. 取得しているロックの合計数</strong></p><p>Most Locks First(MLF)と呼ばれる。</p><p>最も多くのオブジェクトをロックしているトランザクションを優先する手法。この観点は、各オブジェクトの人気度を反映していない。例えば誰も参照しないオブジェクトをいくらロックを取っても全体の処理効率に影響は少ない。</p><p><strong>案2. トランザクションを待たせているロックの合計数</strong></p><p>MostBlocking Locks First(MBLF)と呼ばれる。</p><p>案1と違って、他トランザクションを待たせていない不人気なオブジェクトのロックは無視されている所が改善。ただし、トランザクションを待たせているか否かのゼロイチであるので、さらにその後ろにどれだけ待っているかは考慮していない。</p><p><strong>案3. 依存関係サブグラフの深さ</strong></p><p>DeepestDependency First(DDF)と呼ばれる。</p><p>案1,2 は水平競合と呼ばれるものに焦点を当てている一方、DDFは垂直競合に焦点を当てている。グラフが深いほどに待たせているトランザクションが多い事が期待されるが、正確ではない。</p><p><strong>案4. サブグラフ内の依存関係の数(提案手法)</strong></p><p>Largest-Dependency-Set-First(LDSF)と呼ばれる。</p><p>依存関係のサブグラフにおいて、もっとも依存関係が多いサブグラフを持つトランザクションを優先する。これは、そのトランザクションの下に吊り下がっているトランザクションの合計値で表す事ができる。</p><p><strong>案その他</strong></p><p>各トランザクションの実行時間などは問題の単純化のため考慮していないが、今後機械学習とか導入して、ロックのアクセスパターンや実行時間を考慮できると良いよね、程度に触れている。</p><h4 id=参考>参考</h4><p><a href=http://mysqlserverteam.com/contention-aware-transaction-scheduling-arriving-in-innodb-to-boost-performance/>Contention-Aware Transaction Scheduling Arriving in InnoDB to Boost Performance | MySQL Server Blog</a></p><p><a href=https://dl.acm.org/doi/abs/10.1145/3177732.3177740>Contention-aware lock scheduling for transactional databases | ACM</a></p><p><a href=https://masato.ushio.org/blog/index.php/2018/03/04/uco-tech_mysql-8-0_trx_scheduling_cats/>UCO-Tech（MySQL 8.0のトランザクションスケジューリング：CATS）| UCOブログ</a></p></article></div></div></div><footer class="text-center pb-1"><small class=text-muted>&copy; Copyright 2020, ryosei iwai<br>Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a>
and <a href=https://github.com/austingebauer/devise target=_blank>Devise</a></small></footer></body></html>