<!doctype html><html lang=en><head>
<title>aws-load-balancer-controller が pod を target group に追加するまでの流れ</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<link rel=stylesheet href=../../css/theme.css>
</head>
<body>
<div id=content class=mx-auto><header class="container mt-sm-5 mt-4 mb-4 mt-xs-1">
<div class=row>
<div class="col-sm-4 col-12 text-sm-right text-center pt-sm-4">
<a href=../../ class=text-decoration-none>
<img id=home-image class=rounded-circle src=../../images/avatar.png>
</a>
</div>
<div class="col-sm-8 col-12 text-sm-left text-center">
<h2 class="m-0 mb-2 mt-4">
<a href=../../ class=text-decoration-none>
Ryosei Iwai
</a>
</h2>
<p class="text-muted mb-1">
Software, Infra Engineer / iwakero / GREE, inc.
</p>
<ul id=nav-links class="list-inline mb-2">
<li class=list-inline-item>
<a class="badge badge-white" href=../../about/ title=About>About</a>
</li>
<li class=list-inline-item>
<a class="badge badge-white" href=../../post/ title=Posts>Posts</a>
</li>
<li class=list-inline-item>
<a class="badge badge-white" href=../../categories/ title=Categories>Categories</a>
</li>
<li class=list-inline-item>
<a class="badge badge-white" href=../../tags/ title=tags>Tags</a>
</li>
</ul>
<ul id=nav-social class=list-inline>
<li class="list-inline-item mr-3">
<a href=https://github.com/zensai3805 target=_blank>
<i class="fab fa-github fa-1x text-muted"></i>
</a>
</li>
<li class="list-inline-item mr-3">
<a href=https://twitter.com/zensai3805 target=_blank>
<i class="fab fa-twitter fa-1x text-muted"></i>
</a>
</li>
</ul>
</div>
</div>
<hr>
</header>
<div class=container>
<div class=pl-sm-2>
<div class=mb-3>
<h3 class=mb-0>aws-load-balancer-controller が pod を target group に追加するまでの流れ</h3>
<small class=text-muted>Published January 1, 0001</small>
</div>
<article>
<h1 id=はじめに>はじめに</h1>
<p>aws-load-balancer-controller(albc) は k8s cluster で ALB,NLB を使う際、勝手に LB を立ててくれて勝手に target group の lisner を弄ってくれるので便利</p>
<blockquote>
<p>AWS Load Balancer Controller
<a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller>https://github.com/kubernetes-sigs/aws-load-balancer-controller</a></p>
</blockquote>
<p>k8s & LB であるあるの問題が rolling update 時の 502 で、これは両者が非同期で処理を進めることに起因する</p>
<p>原因としては以下の記事が見やすく、</p>
<blockquote>
<p>スマホゲームの API サーバにおける EKS の運用事例
<a href=https://labs.gree.jp/blog/2020/01/20271/>https://labs.gree.jp/blog/2020/01/20271/</a></p>
</blockquote>
<p>対応としてはこの辺も参考になる</p>
<blockquote>
<p>[AWS][EKS] Zero downtime deployment(RollingUpdate) when using ALB Ingress Controller on Amazon EKS
<a href=https://easoncao.com/zero-downtime-deployment-when-using-alb-ingress-controller-on-amazon-eks-and-prevent-502-error/>https://easoncao.com/zero-downtime-deployment-when-using-alb-ingress-controller-on-amazon-eks-and-prevent-502-error/</a></p>
</blockquote>
<blockquote>
<p>NEG とは何か
<a href=https://medium.com/google-cloud-jp/neg-%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B-cc1e2bbc979e>https://medium.com/google-cloud-jp/neg-%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B-cc1e2bbc979e</a></p>
</blockquote>
<p>ざっくりな原因は、</p>
<ul>
<li>pod の terminate 時に target group から削除されている保証がない</li>
<li>pod の terminate 時に、代わりの pod 達が target group で healthy になっている保証がない</li>
</ul>
<p>の2点で、</p>
<ul>
<li>前者は pod の <code>preStop</code> と <code>terminationGracePeriodSeconds</code> を伸ばす</li>
<li>後者は container に readinessGate を登録する
<ul>
<li>k8s側の <a href=https://kubernetes.io/ja/docs/concepts/workloads/pods/pod-lifecycle/>Podのライフサイクル</a> とalbc側の <a href=https://kubernetes-sigs.github.io/aws-load-balancer-controller/v2.1/deploy/pod_readiness_gate/>Pod readiness gate</a> が参考になる</li>
</ul>
</li>
</ul>
<p>で対応する事がプラクティスとして言われている</p>
<p>pod の READY になる条件に target group 側でヘルスチェックが通ってる事を追加する事で rolling update 時の性急な terminate を抑制するのは分かるが、これはつまり notREADY な pod が target group に登録されているということ。では、ALB から見て pod がアクセスを捌けるという事はどうやって保証しているのか？</p>
<p>本記事では albc のコードを読み解くことで、上記の問題への対応を見ていく</p>
<h1 id=詳細>詳細</h1>
<h2 id=pod-を-target-group-へ登録する3ステップ>pod を target group へ登録する3ステップ</h2>
<p>albc は、以下のステップにて新規 pod を登録する。ざっくりなコードは<a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller/blob/da8951f80521651e0a1ffe1361c011d6baad7706/pkg/targetgroupbinding/resource_manager.go#L92-L144>ここ</a>で、その中の <a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller/blob/da8951f80521651e0a1ffe1361c011d6baad7706/pkg/backend/endpoint_resolver.go#L53-L122>ResolvePodEndpoints</a> が追加するエンドポイントを取得している</p>
<ol>
<li>target group の port と同じ port が設定されている service を取得する</li>
<li>上記 port と同一の port が設定されているエンドポイント(notReady含)を取得する</li>
<li>notReady なエンドポイントの内、 <code>readinessGate</code> が設定されており <code>containersReady</code> なエンドポイントを、 target group に登録する</li>
</ol>
<p>それぞれの詳細は下に書くが、ここで重要なのは target group への登録対象として、 <code>containersReady</code> である事を保証している事である</p>
<p>上の方に書いた</p>
<blockquote>
<p>ALB から見て pod がアクセスを捌けるという事はどうやって保証しているのか？</p>
</blockquote>
<p>への回答は、コンテナに readinessProbe を設定する事でコンテナがアクセスを捌ける事を保証し、チェックが通った(=containersReady)な pod を登録している、ということになる</p>
<p>以上でこの記事の結論が出てしまった訳だが、一応上記ステップについて細かく触れていく</p>
<p>ただコードのリンクを飛び飛びで貼っているので、素直に自分で上記のコードを読んだ方が早い気がしないでもない</p>
<h3 id=ステップ詳細>ステップ詳細</h3>
<h4 id=target-group-の-port-と同じ-port-が設定されている-service-を取得する>target group の port と同じ port が設定されている service を取得する</h4>
<p><a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller/blob/da8951f80521651e0a1ffe1361c011d6baad7706/pkg/backend/endpoint_resolver.go#L157-L171>findServiceAndServicePort</a> で k8s API( <a href=https://kubernetes.io/docs/reference/kubernetes-api/service-resources/service-v1/>Service</a> ) を叩き、 service 一覧を取得した後、 <a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller/blob/da8951f80521651e0a1ffe1361c011d6baad7706/pkg/k8s/service_utils.go#L10-L26>LookupServicePort</a> で service を絞っている</p>
<h4 id=上記-port-と同一の-port-が設定されているエンドポイントnotready含を取得する>上記 port と同一の port が設定されているエンドポイント(notReady含)を取得する</h4>
<p>エンドポイント一覧を<a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller/blob/da8951f80521651e0a1ffe1361c011d6baad7706/pkg/backend/endpoint_resolver.go#L63-L70>ここ</a>で k8s API( <a href=https://kubernetes.io/docs/reference/kubernetes-api/service-resources/endpoints-v1/>Endpoints</a> )を叩いて取得している。</p>
<p>当初、k8s上ではこの時点で新podは READY ではなく service のエンドポイントには新podは登録されていないと考えていたが、API reference を読んでみると、 <code>NotReadyAddresses</code> として取得できる事が分かった</p>
<h4 id=notready-なエンドポイントの内-readinessgate-が設定されており-containersready-なエンドポイントを-target-group-に登録する>notReady なエンドポイントの内、 <code>readinessGate</code> が設定されており <code>containersReady</code> なエンドポイントを、 target group に登録する</h4>
<p>notReady な pod 達は<a href=https://github.com/kubernetes-sigs/aws-load-balancer-controller/blob/da8951f80521651e0a1ffe1361c011d6baad7706/pkg/backend/endpoint_resolver.go#L95-L117>ここ</a>で以下のチェックが入る</p>
<ul>
<li>ReadinessGate が設定されているかどうか
<ul>
<li>ReadinessGate が設定されていない pod は素直に READY になってから登録すれば良い</li>
</ul>
</li>
<li>containersReady かどうか
<ul>
<li>containersReady でない、つまり readinessProbe を通っていない pod はアクセスを捌ける保証がないので、登録しない</li>
</ul>
</li>
</ul>
<p>以上が登録部分の概要である。この辺は k8s cluster と AWS(ALB) がどう同期を取るかという所が工夫されていて、読んでいて面白かった。一方で僕の感じた疑問の回答がネットで見つけられなかったので、ここに残しておくという訳だ</p>
<p>以上</p>
</article>
</div>
</div>
</div><footer class="text-center pb-1">
<small class=text-muted>
&copy; Copyright 2020, ryosei iwai
<br>
Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a>
and <a href=https://github.com/austingebauer/devise target=_blank>Devise</a>
</small>
</footer>
</body>
</html>